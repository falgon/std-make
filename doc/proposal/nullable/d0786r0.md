<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="607">
    <tr>
        <td width="172" align="left" valign="top">Document number:</td>
        <td width="435"><span style="background-color: #FFFF00">D0786R0</span></td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Date:</td>
        <td width="435">2017-10-08</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Project:</td>
        <td width="435">ISO/IEC JTC1 SC22 WG21 Programming Language C++</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Audience:</td>
        <td width="435">Library Evolution Working Group</td>
    </tr>
    <tr>
        <td width="172" align="left" valign="top">Reply-to:</td>
        <td width="435">Vicente J. Botet Escrib&aacute; &lt;<a href="mailto:vicente.botet@wanadoo.fr">vicente.botet@nokia.com</a>&gt;</td>
    </tr>
</table>

# *ValuedOrError* and *ValueOrNone* types
============================================================

**Abstract**

There are types that contain a success value or a failure value.

In the same way we have *Nullable* types that have a single not-a-value we have types that can contain a single instance of value-type and a mean to retrieve it using  the `deref` function. These types have something in common with *Nullable* and is the ability to know if they have a value or not via the `has_value` function. Types that are possibly valued and have a single error are named in this paper *ValedOrError*. They provide the `error` function. `optional`, pointers and smart pointers are *ValeuOrNone* types. `expected` is a *ValuedOrError* type. The ongoing `result<T>` is also a *ValuedOrError*.


# Table of Contents

* [Introduction](#introduction)
* [Motivation and Scope](#motivation-and-scope)
* [Proposal](#proposal)
* [Design Rationale](#design-rationale)
* [Proposed Wording](#proposed-wording)
* [*Implementability](#implementability)
* [Open points](#open-points)
* [Acknowledgements](#acknowledgements)
* [History](#history)
* [References](#references)

# Introduction


This paper proposes the concept of *ValueOrError* that represents a type that can contain a success value or a failure value that can be used as the result of a function to return the value computed by the function or the reason of the failure of this computation. 

*ValueOrError* contains the interface needed to customize the types that can work with the proposed `operator try`. This makes the error propagation on functions returning this kind of types much more simpler.

The paper proposes also some error handling utilities that help while the user wants to recover from error as `resolve`,  `value_or`, `value_or_throw`, `error_or` and `check_error`. 

When the type is *TypeConstructible* and *ValueOrError*, the type can be seen as a *Functor*, an *ApplicativeFunctor*, a *Monad* or a *MonadError*. 

Some *ValueOrError* types contain success and/or failure types that wrap a value or an error. However, the user wants to see the wrapped value and error types instead of the wrapping success and failure types. These types unwrap the wrapped value before calling to the user provided functions.

*ValueOrError* as a *SumType* can provide the `visit` function. However we cannot specialize the variant-like traits, nor, the `get<I>` functions. Nevertheless we could specialize the *SumType* traits.


<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="807">
    <tr>
        <td align="left" valign="top"> BEFORE </td>
        <td align="left" valign="top"> AFTER </td>
    </tr>
    <tr>
        <td  align="left" valign="top"><b>
Construction
        </b></td>
        <td  align="left" valign="top"><b>
        </b></td>
    </tr>
    <tr>
        <td align="left" valign="top"><pre class='brush: cpp'>

        </pre>
        </td>
        <td align="left" valign="top"><pre class='brush: cpp'> 
        </pre>
        </td>
    </tr>
    <tr>
        <td  align="left" valign="top"><b>
Conversion

        </b></td>
        <td  align="left" valign="top"><b>
        </b></td>
    </tr>
    <tr>
        <td align="left" valign="top"><pre class='brush: cpp'>

        </pre>
        </td>
        <td align="left" valign="top"><pre class='brush: cpp'> 
        </pre>
        </td>
    </tr>
    <tr>
        <td  align="left" valign="top"><b>
Return
        </b></td>
        <td  align="left" valign="top"><b>
        </b></td>
    </tr>
    <tr>
        <td align="left" valign="top"><pre class='brush: cpp'>

        </pre>
        </td>
        <td align="left" valign="top"><pre class='brush: cpp'> 
        </pre>
        </td>
    </tr>
    
       
</table>

# Motivation and Scope

## Towards an `operator try`

[P0799R0] proposes a new `operator try` that would make much simpler the use of `std::optional` and `std::experimental::expected` as result type of a function.

The customization of the `operator try` consists in returning a type that has 3 functions:

* check for the success of the computation of the parameter
* get the value of the success path
* get the value of the failure path

The result type of getting the failure paths must be implicitly convertible to the return type of the function calling the `operator try` and the value of the success must be implicitly convertible (assignable?) to the type of the *try-expression*.  

The name of these functions depend on the concept we want to abstract. If we name this concept *ValueOrError* they could be:

* `succeeded `or `failed`
* `success_value`
* `failure_value`

Here it is an example:
 
```
U h(T);

X<T,E> f();

X<U,E> g() {
    auto t =  try f();
    return h(t);  
}  
```

The meaning of a *try-expression* is given by the following transformation

```c++
X<U,E> g() {
    auto __trier = operator try(f());
    if ( __trier.failed() )
        return __trier.failure_value();
    auto t = __trier.success_value();    
    return h(t);  
}  
```


## *ValueOrError* operations

While the use of *try-expresssions* is good to propagate failure, we need some generic functions if we want to do something else.

We propose a concept *ValueOrError* that allows to customize the 4 functions and provide access via

* `value_or_error::succeeded`
* `value_or_error::failed`
* `value_or_error::success_value`
* `value_or_error::failure_value`

`value_or_error::failed` must be the negation of  `value_or_error::succeeded`.

We can then overload the `operator try` for this concept

```c++
template <ValueOrError T>
constexpr auto operator try(T&&)
{
    struct tryer {
        T&& v;
        
        constexpr bool succeeded() const noexcept 
        { return value_or_error::succeeded(v) }
        constexpr bool failed() const noexcept 
        { return value_or_error::failed(v) }
        constexpr auto success_value() const noexcept 
        { return value_or_error::success_value(move(v)) }
        constexpr auto failure_value() const noexcept 
        { return value_or_error::failure_value(move(v)) }
    };
    return tryer{ std::move(v) };
}
```

I don't know if the proposed *try-expression* interpretation is best way,  
however given the previous concept *ValueOrError* we could interpret the *try-expression* alternatively as follows 

```c++
X<U,E> g() {
    auto __tmp = f();
    if ( value_or_error::failed(__tmp) )
        return value_or_error::failure_value(move(__tmp));
    auto t = value_or_error::success_value(move(__tmp));    
    return h(t);  
}  
```

This interpretation is more in line with the transformation of the range-based for loop, which could be seen as simpler but makes again the language dependent on the library.

Note that a *ValueOrError* can be seen as a *Tryable* and vice-versa. However using the 'operator try' in other contexts than failure propagation, is cumbersome. 

```c++
template <Tryable X, class T>
auto value_or(X&& x, T&& v) 
{
    auto tryer = operator try(forward<X>(x));
    if ( tryer.succeeded())
        return tryer.success_value();    
    return forward<T>(v);
}
```

The advantage of basing the `operator try` on the `tryer` instead of on direct use of the *ValueOrError* concepts is that the language definition doesn't depends on concrete things. 

## Error handling with *ValueOrError*

While the *try-expression* is used to propagate the error as such, the user needs at a given moment recover or propagate a different error. Next we describe some these utilities.

### Do we need a generic `value_or` function?

We have `optional::value_or()` and `expected::value_or()` functions with a similar definition. This function can be defined in a generic way for *ValueOrError* types as follows

```c++
template <ValueOrError X, class T>
auto value_or(X&& x, T&& v) 
{
    using namespace value_or_error;
    if ( succeeded(forward<X>(x)) )
        return success_value(move(x));    
    return forward<T>(v);
}
```

### Do we need a generic `value_or_throw` function?

We have `optional::value()` and `expected::value()` functions with a similar definition, but returning a specific exception. It has been argued that the user need sometimes to throw a specific exception more appropriated to his context. We can define a function for *ValueOrError* types that allows to specify the exception to throw as follows

```c++
template <class E, ValueOrError X>
auto value_or_throw(X&& x) 
{
    using namespace value_or_error;
    if ( succeeded(forward<X>(x)) )
        return success_value(move(x));    
    throw E{failure_value(move(x))};
}
```
### Do we need a generic `resolve` function?

The previous function `value_or_throw` is a special case of error handling. We can have a more general one `resolve` that takes a function having as parameter the failure type.

```c++
template <ValueOrError X, class F>
auto resolve(X&& x, F&& f) 
{
    using namespace value_or_error;
    if ( succeeded(forward<X>(x)) )
        return success_value(move(x));    
    throw invoke(forward<F>(f), failure_value(move(x)));
}
```

With this definition `value_or` could be defined as

```c++
template <ValueOrError X, class T>
auto value_or(X&& x, T v) 
{
    return resolve(forward<X>(x), [v](auto &&failure) {
        return v;
    });
}
```

and `value_or_throw` could be defined as

```c++
template <class E, ValueOrError X>
auto value_or_throw(X&& x) 
{
    return resolve(forward<X>(x), [](auto &&failure) {
        throw E{failure};
    });
}
```

### Do we need a generic `error_or` function?

It has been argued that the error should be always available and that often there
is a success value associated to the error. We have the `status_value` proposal
and `expected<T,E>` could be seen more like something like the proposed

```
struct status_value {
    E error; 
    optional<T> opt_value;
};
```

The following code shows a use case

```c++
auto e = function();
switch (e.status())
	success: ....; break;
	too_green: ....; break;
	too_pink: ....; break;
```

With the current interface the user could be tempted to do

```c++
auto e = function();
if (e)
	/*success:*/ ....;
else
	switch (e.error())
	case too_green: ....; break;
	case too_pink: ....; break;
```
	
This could be done with the current interface as follows

```c++
auto e = function();
switch (error_or(e, success))
	success: ....; break;
	too_green: ....; break;
	too_pink: ....; break;
```

where

```c++
template <ValueOrError X, class E>
E error_or(X && x, E&& err) {
    using namespace value_or_error;
    if ( failed(forward<X>(x) )
        return failure_value(move(x));    
    return forward<E>(err);
}
```

### Need for *ValueOrError* `error`

Note that the previous `value_or` function works for `optional` and `expected` as both have a success type that match the value type. However, `error_or` doesn't works for `expected` as `expected<T,E>` is not implicitly convertible from `E` but from `unpexpected<E>` which wraps an `E`.

For *ValueOrError* types for which the success type wraps the value type and/or the failure type wraps the error type, we need to unwrap the success/failure type to get a value/error type. 

```
template <ValueOrError X, class T>
auto value_or(X&& x, T&& v) 
{
    using namespace value_or_error;
    if ( succeeded(forward<X>(x) )
        return wrapped::unwrap(success_value(move(x)));    
    return forward<T>(v);
}
```

For this *ValueOrError* types it will be better to define 2 functions that unwrap directly the success or the failure value


```
namespace value_or_error {
    template <class X>
    auto deref(X&& x) 
    {
        return wrapped::unwrap(success_value(move(x)));    
    }
    template <class X>
    auto error(X&& x) 
    {
        return wrapped::unwrap(failure_value(move(x)));    
    }
    template <class X>
    auto has_value(X const& x) 
    {
        return succeeded(x);    
    }
    template <class X>
    auto has_error(X const& x) 
    {
        return failed(x);    
    }

}
```


With these definitions

```
template <ValueOrError X, class T>
auto value_or(X&& x, T&& v) 
{
    using namespace value_or_error;
    if ( has_value(forward<X>(x) )
        return deref(move(x)));    
    return forward<T>(v);
}

template <ValueOrError X, class E>
E error_or(X && x, E&& err) {
    using namespace value_or_error;
    if ( has_error(forward<X>(x) )
        return error(move(x));    
    return forward<E>(err);
}
```

If `wrapped::unwrap` is the identity for non-wrapped types, we have that the previous definition works well for any *ValueOrError* types.


### Do we need a generic `check_error` function?

Another use case which could look much uglier is if the user had to test for whether or not there was a specific error code.

```c++
auto e = function();
while ( e.status == timeout ) {
	sleep(delay);
	delay *=2;
	e = function();
}
```

Here we have a value or a hard error. This use case would need to use something like `check_error` 

```c++
e = function();
while ( check_error(e, timeout) )
{
	sleep(delay);
	delay *=2;
	e = function();
}
```

where

```c++
template <ValueOrError X, class E>
bool check_error(X const& e, E&& err) {
    using namespace value_or_error;
    if ( succeeded(x) )
        return false;    
    return failure_value(x)) == forward<E>(err);
}
```

We can extend the scope of this function by using instead *ValueOrError*

```c++
template <ValueOrError X, class E>
bool check_error(X const& e, E&& err) {
    using namespace value_or_error;
    if ( has_value(x) )
        return false;    
    return error(x)) == forward<E>(err);
}
```

# Proposal

This paper proposes to

* add `succeeded(n)`/`has_value(n)`, `failed(n)`/has_error(n), `success_value(n)`, `failure_value(n)`, `deref(n)` and `error(n)` for *ValuedOrError* types,
* add *ValueOrNone* types as an extension of *Nullable* types for which there is only a possible value type, adding the `deref(n)` function,
* *ValueOrNone* type are *ValuedOrError* types considering none_t as the `failure_type` and the `error_type`.
* add the following helper functions for *ValuedOrError* types
    * `value_or`,
    * `value_or_throw`,
    * `resolve`,
    * `error_or` and,
    * `check_error`.
    
* customize the standard types `std::optional`, smart pointers, `std::experimental::expected` to these concepts.

# Design Rationale

## Customization

### Traits versus ADL

## Naming

# Impact on the standard

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++17. There are however some classes in the standard that needs to be customized.

This paper depends in some way on the helper classes proposed in [P0343R1], as e.g. the place holder `_t` and the associated specialization for the type constructors `optional<_t>`, `unique_ptr<_t>`, `shared_ptr<_t>`.

# Proposed Wording

The proposed changes are expressed as edits to [N4564] the Working Draft - C++ Extensions for Library Fundamentals V2, but pretend to go to the V3 TS.

This wording will be completed if there is an interest in the proposal.


**Adapt the "ValueOrError Objects" section**

## ValueOrError Objects


### Header <experimental/wrapped> synopsis [Wrapped.synop]


### Header <experimental/value_or_error> synopsis [ValueOrError.synop]

```c++
namespace std::experimental {
inline namespace fundamentals_v3 {
namespace value_or_error {

    // class traits
    template <class T, class Enabler=void>
        struct traits {};

    template <class T> constexpr bool succeeded(T const& v) noexcept;
    template <class T> constexpr bool failed(T const& v) noexcept;
    template <class T> constexpr bool succeeded(T* v) noexcept;
    template <class T> constexpr bool failed(T* v) noexcept;
        
    template <class T> constexpr auto succeess_value(T&& x);
    template <class T> constexpr T& succeess_value(T* ptr);
        
    template <class T>
        using success_type_t = decltype(succeess_value(declval<T>));        

    template <class T> constexpr auto failure_value(T&& x);
    template <class T> constexpr T& failure_value(T* ptr);
        
    template <class T>
        using success_type_t = decltype(failure_value(declval<T>));                        
        
    template <class T> constexpr bool has_value(T const& v) noexcept;
    template <class T> constexpr bool has_value(T* v) noexcept;
    template <class T> constexpr bool has_error(T const& v) noexcept;
    template <class T> constexpr bool has_error(T* v) noexcept;
        
    template <class T> constexpr auto deref(T&& x);
    template <class T> constexpr T& deref(T* ptr);
        
    template <class T>
        using value_type_t = decltype(value_or_error::deref(declval<T>));        
       
    template <class T> constexpr auto error(T&& x);
    template <class T> constexpr T& error(T* ptr);

    template <class T>
        using error_type_t = decltype(value_or_error::error(declval<T>));        

          
}
 
    template <class T> struct is_value_or_error;
    template <class T>
        struct is_value_or_error <const T> : is_value_or_error <T> {};
    template <class T>
        struct is_value_or_error <volatile T> : is_value_or_error <T> {};
    template <class T>
        struct is_value_or_error <const volatile T> : is_value_or_error <T> {};
    template <class T>
        struct is_value_or_error <T*> : true_type {};

    template <class T>
        constexpr bool is_value_or_error_v = is_value_or_error <T>::value ;
        
namespace value_or_error {

    // when type constructible, is a functor
    template <class T, class F> constexpr auto transform(T&& n, F&& f); 

    // when type constructible, is an applicative
    template <class F, class T> constexpr auto ap(F&& f, T&& n); 

    // when type constructible, is a monad
    template <class T, class F> constexpr auto bind(T&& n, F&& f); 

    // when type constructible, is a monad_error
    template <class T, class F> constexpr auto catch_error(T&& n, F&& f); 
    template <class T, class ...Xs> constexpr auto make_error(Xs&&...xs); 

    // sum_type::visit
    template <class N, class F> constexpr auto visit(N&& n, F&& f); 
        
    // helper functions    
    template <class N, class E> constexpr auto error_or(N&& ptr, E&& err); 
                
    template <class N, class E> constexpr bool check_error(N&& n, E&& err); 
          
    template <class N, class F>
        constexpr auto resolve(N&& n, F&& f); 

    template <class X, class T>
        constexpr auto value_or(X&& ptr, T&& val); 
                
    template <class E, class X>
        constexpr auto value_or_throw(X&& ptr); 
                
    template <class X, class E>
        constexpr auto error_or(X&& ptr, E&& err); 
                
    template <class X, class E>
        constexpr bool check_error(X&& n, E&& err); 
          
    template <class X, class F, class T>
        constexpr auto apply_or(X&& n, F&& f, T&& v); 

    template <class X, class F>
        constexpr auto resolve(X&& n, F&& f); 
        
}
        
}
}
```

###  class `traits` [value_or_error.traits]

```c++
namespace value_or_error {
    // class traits
    template <class T, class Enabler=void>
        struct traits {};

    // class traits_pointer_like
    struct traits_pointer_like
    {
        template <class Ptr>
            static constexpr
            bool succeeded(Ptr ptr);
        template <class T>
            static constexpr bool failed(Ptr ptr) noexcept;        
        template <class T>
            static constexpr auto succeess_value(Ptr ptr);        
        template <class T>
            static constexpr auto failure_value(Ptr ptr);

        template <class Ptr>
            static constexpr
            bool has_value(Ptr ptr);
    };

    // class traits specialization for pointers
    template <class T>
        struct traits<T*> 
            : traits_pointer_like<T*>
        {};        
} 
```
###  Template function `succeeded` [value_or_error.succeeded]

```c++
namespace value_or_error {
    template <class T>
        bool succeeded(T const& v) noexcept;
}
```

###  Template function `failed` [value_or_error.failed]

```c++
namespace value_or_error {
    template <class T>
        bool failed(T const& v) noexcept;
}
```


###  Template function `has_value` [value_or_error.has_value]

```c++
namespace value_or_error {
    template <class T>
        constexpr bool has_value(T const& v) noexcept;
    template <class T>
        constexpr bool has_value(T* v) noexcept;
}
```

**Adapt the "ValueOrNone Objects" section**

## ValueOrNone Objects


### Header <experimental/value_or_none> synopsis [ValueOrNone.synop]

```c++
namespace std::experimental {
inline namespace fundamentals_v3 {
 
    template <class T> struct is_value_or_none;

    template <class T>
        constexpr bool is_value_or_none_v = is_value_or_none <T>::value ;

    template <class T>
        struct is_value_or_none<const T> : is_value_or_none<T> {};
    template <class T>
        struct is_value_or_none<volatile T> : is_value_or_none<T> {};
    template <class T>
        struct is_value_or_none<const volatile T> : is_value_or_none<T> {};

namespace value_or_none {
    using namespace nullable;
    
    // class traits 
    template <class T>
        struct traits;
        
    // class traits_pointer_like
    struct traits_pointer_like    
    {
        template <class U> static constexpr auto deref(U && ptr);
    };

    // class traits specialization for pointers
    template <class T> struct traits<T*> : traits_pointer_like<T*> {};
        
    template <class T> constexpr auto deref(T&& x);
    template <class T> constexpr T& deref(T* ptr);

    template <class T>
        using value_type_t = decltype(value_or_none::deref(declval<T>));        

    template <class T> constexpr auto deref_none(T&& );
    template <class T> constexpr nullptr_t deref_none(T*) noexcept;
    
namespace value_or_error
{
  template <class T>
  struct traits<T, meta::when<is_value_or_none<T>::value>>  
        : mcd_success_or_failure
  {
      template <class U> static constexpr bool succeeded(U && u);

      template <class U> static constexpr auto success_value(U && u);

      template <class U> static constexpr auto failure_value(U && u);
  };
}

}
}
}
```


## Optional Objects

**Add Specialization of *ValueOrNone* [optional.object.value_or_none]**.

20.6.x *ValueOrNone* specialization

`optional<T>` is a model of *ValueOrNone*.

```c++
namespace value_or_none {
    template <class T>
    struct traits<optional<T>> : traits_pointer_like{};
}
```   

## Smart Pointers

20.6.x *ValueOrNone* specialization

`unique_ptr<T, D>` is a models of *ValueOrNone*.

```c++
namespace value_or_none {
    template <class T, class D>
    struct traits<unique_ptr<T, D> : traits_pointer_like {};
}
```

`shared_ptr<T>` is a models of *ValueOrNone*.

```c++
namespace value_or_none {
    template <class T>
    struct traits<shared_ptr<T>> : traits_pointer_like {};
}
```

## Expected Objects

**Add Specialization of *Wrapped* [unexpected.object.wrapped]**.

```c++
namespace wrapped
{
template <class E>
struct traits<unexpected<E>> 
{
    template <class U>
    static constexpr
    auto unwrap(U && u);

};
}
```

**Add Specialization of *ValueOrError* [expected.object.value_or_error]**.

```c++
namespace value_or_error
{
template <class T, class E>
struct traits<expected<T,E>> : mcd_success_or_failure
{
    template <class U>
        static constexpr
        bool succeeded(U && e) noexcept;

    template <class U>
        static constexpr
        auto success_value(U && e);

    // This is the major reason for having expected::get_unexpected. Error propagation.
    // We could do it unexpected and expected::error, but then we cannot return a reference.
    // return unexpected(e.error())
    template <class U>
    static constexpr
    auto failure_value(U && e);
};
}
```


# Implementability

This proposal can be implemented as pure library extension, without any language support, in C++17.

See [VOE_impl] and [VON_impl].

# Open points

The authors would like to have an answer to the following points if there is any interest at all in this proposal:

## *ValueOrError*

### `succeeded` versus `has_value`

### `failed` versus `has_error`?

### `success_value`?

### `failure_value`?

### `deref`?

### `error`?

## File(s) name

Should we include this in `<experimental/functional>` or in a specific file?
We believe that a specific file is a better choice as this is needed in `<optional>` and  `<experimental/expected>`. We propose to locate each concept in its one file `<experimental/valued_or_error>`/`<experimental/valued_or_none>`. 

## About `value_or_error::value(n)`

We could define a wide `value_or_error::value(n)` function on *ValueOrError* that obtain the value or throws an exception. If we want to have a default implementation the function will need to throw a generic exception `bad_access`.

However to preserve the current behavior of `std::optional::value()`/`std::expected::value()` we will need to be able to consider this function as a customization point also.

The user can alternatively use `value_or_throw`, which allows to specify the exception.

Do we want a `value_or_error::value` function that throw `bad_access`?

Do we want a customizable `value_or_error::value`? Should the exceptions throw by this function inherit from a common exception class `bad_access`?

# Future work

We have an implementation of the following, but we don't have wording yet.

## *ValueOrError* as SumType

A *ValueOrError* can be considered as a sum type. It is always useful reflect the related types. `value_or_error::error_type_t` and `value_or_error::value_type_t` give respectively the associated non-a-value and the value types.

## *ValueOrError* as a Functor

While we don't have yet an adopted proposal for *Functor*, we can define a default `value_or_error::transform` function for *ValueOrError* type. 

## *ValueOrError* as an Applicative Functor

While we don't have yet an adopted proposal for *ApplicativeFunctor*, we can define a default `value_or_error::ap` function for *ValueOrError*. 

## *ValueOrError* as a Monad

While we don't have yet an adopted proposal for *Monad*, we can define a default `value_or_error::bind` function for *ValueOrError*. 

## *ValueOrError* as a MonadError

While we don't have yet an adopted proposal for *MonadError*, we can define a default `value_or_error::catch_error` and `value_or_error::make_error` functions for *ValueOrError*. 

# Acknowledgements

Thanks to Niall for his idea of the `operator try` which motivated the definition of these concepts and for which a direct implementation is possible.

Special thanks and recognition goes to Technical Center of Nokia - Lannion for supporting in part the production of this proposal.

# History

## Revision 0

* Extract `deref()`/`visit()` and the derived alogorithms as `value_or` and `error_or`  from [P0196R3] and define *ValueOrError*/*ValueOrNone*, as `std::any` cannot define `deref()` and `std::any` should be *Nullable*. 
     
# References

[N4564]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4564.pdf "N4564 - Working Draft, C++ Extensions for Library Fundamentals, Version 2 PDTS"

[P0032R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0032r0.pdf "Homogeneous interface for variant, any and optional"

[P0050R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0050r0.pdf "C++ generic match function"

[P0088R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0088r0.pdf "Variant: a type-safe union that is rarely invalid (v5)"  

[P0091R0]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0091r0.html "Template parameter deduction for constructors (Rev. 3)"

[P0196R3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0196r3.html "Generic `none()` factories for *Nullable* types (Rev. 3)"
    
[P0779R0]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0779r0.pdf "Proposing operator try()"   

[P0338R2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0338r2.pdf "C++ generic factories"

[P0343R1]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0343r1.pdf "Meta-programming High-Order functions"

[CWG 1630]: http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1630 "Multiple default constructor templates" 

[SUM_TYPE]: https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/sum_type "Generic Sum Types"

[VOE_impl]: https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/value_or_error "ValueOrError types"   

[VON_impl]: https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/value_or_none "ValueOrNone types"
       

* [N4564] N4564 - Working Draft, C++ Extensions for Library Fundamentals, Version 2 PDTS

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4564.pdf

* [P0032R0] Homogeneous interface for variant, any and optional

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0032r0.pdf

* [P0050R0] C++ generic match function

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0050r0.pdf

* [P0088R0] Variant: a type-safe union that is rarely invalid (v5)

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0088r0.pdf

* [P0091R0] Template parameter deduction for constructors (Rev. 3)

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0091r0.html

* [P0196R3] Generic `none()` factories for *Nullable* types (Rev. 3)

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0196r3.html
    
* [P0338R2] C++ generic factories

    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0338r2.pdf

* [P0343R1] - Meta-programming High-Order functions

    http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0343r1.pdf

* [P0779R0] Proposing operator try()

    http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0779r0.pdf

* [CWG 1630] Multiple default constructor templates  

    http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1630

* [SUM_TYPE] Generic Sum Types

    https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/sum_type

* [VOE_impl] ValueOrError types

    https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/value_or_error

* [VON_impl] ValueOrNone types

    https://github.com/viboes/std-make/tree/master/include/experimental/fundamental/v3/value_or_none
